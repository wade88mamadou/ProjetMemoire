#!/usr/bin/env python
"""
Script d'impl√©mentation des optimisations recommand√©es
Impl√©mente les am√©liorations de performance identifi√©es
"""

import os
import sys
import django
from datetime import datetime

# Configuration Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend_project.settings')
django.setup()

from django.conf import settings
from django.core.cache import cache
from django.db import connection

class ImplementationOptimisations:
    """Classe pour impl√©menter les optimisations"""
    
    def __init__(self):
        self.results = {
            'implementations': [],
            'erreurs': [],
            'succes': []
        }
    
    def log_implementation(self, nom, details, statut):
        """Log une impl√©mentation"""
        self.results['implementations'].append({
            'nom': nom,
            'details': details,
            'statut': statut,
            'timestamp': datetime.now().isoformat()
        })
        
        if statut == 'succes':
            self.results['succes'].append(nom)
            print(f"‚úÖ {nom}: {details}")
        else:
            self.results['erreurs'].append(nom)
            print(f"‚ùå {nom}: {details}")
    
    def implementer_cache_redis(self):
        """Impl√©menter le cache Redis"""
        try:
            # V√©rifier si Redis est disponible
            cache.set('test_redis', 'test_value', 60)
            test_value = cache.get('test_redis')
            
            if test_value == 'test_value':
                # Configurer le cache pour les statistiques
                from api.models import Patient, DossierMedical, Alerte, Utilisateur
                
                # Mettre en cache les statistiques principales
                stats = {
                    'total_patients': Patient.objects.count(),
                    'total_dossiers': DossierMedical.objects.count(),
                    'total_alertes': Alerte.objects.count(),
                    'total_utilisateurs': Utilisateur.objects.count(),
                }
                
                for key, value in stats.items():
                    cache.set(f'stats_{key}', value, 300)  # 5 minutes
                
                self.log_implementation(
                    "Cache Redis",
                    "Cache configur√© avec succ√®s pour les statistiques",
                    "succes"
                )
            else:
                self.log_implementation(
                    "Cache Redis",
                    "Redis non disponible, utilisation du cache par d√©faut",
                    "erreur"
                )
                
        except Exception as e:
            self.log_implementation(
                "Cache Redis",
                f"Erreur lors de la configuration: {e}",
                "erreur"
            )
    
    def implementer_compression_gzip(self):
        """Impl√©menter la compression GZIP"""
        try:
            # V√©rifier si la compression est d√©j√† activ√©e
            if hasattr(settings, 'MIDDLEWARE'):
                middleware_list = list(settings.MIDDLEWARE)
                
                # Ajouter le middleware de compression si pas pr√©sent
                if 'django.middleware.gzip.GZipMiddleware' not in middleware_list:
                    middleware_list.insert(0, 'django.middleware.gzip.GZipMiddleware')
                    
                    # Mettre √† jour les settings (en lecture seule, donc on affiche juste)
                    print("üìù Pour activer GZIP, ajoutez dans settings.py:")
                    print("MIDDLEWARE = [")
                    print("    'django.middleware.gzip.GZipMiddleware',")
                    print("    # ... autres middleware")
                    print("]")
                    
                    self.log_implementation(
                        "Compression GZIP",
                        "Instructions d'activation fournies",
                        "succes"
                    )
                else:
                    self.log_implementation(
                        "Compression GZIP",
                        "D√©j√† activ√©e dans les settings",
                        "succes"
                    )
            else:
                self.log_implementation(
                    "Compression GZIP",
                    "Configuration MIDDLEWARE non trouv√©e",
                    "erreur"
                )
                
        except Exception as e:
            self.log_implementation(
                "Compression GZIP",
                f"Erreur lors de la v√©rification: {e}",
                "erreur"
            )
    
    def optimiser_requetes_viewset(self):
        """Optimiser les ViewSets avec select_related et prefetch_related"""
        try:
            # Cr√©er un fichier de patch pour les ViewSets
            patch_content = '''
# Optimisations pour les ViewSets
# √Ä ajouter dans api/views.py

class PatientViewSet(AuditAccessMixin, viewsets.ModelViewSet):
    serializer_class = PatientSerializer
    
    def get_queryset(self):
        return Patient.objects.select_related(
            'profession', 'residence', 'logement', 
            'comportement', 'alimentation'
        ).all()

class DossierMedicalViewSet(AuditAccessMixin, viewsets.ModelViewSet):
    serializer_class = DossierMedicalSerializer
    
    def get_queryset(self):
        return DossierMedical.objects.select_related(
            'patient__profession', 'patient__residence'
        ).prefetch_related(
            'analyse_set', 'alerte_set', 'vaccin_set', 'infection_set'
        ).all()

class AlerteViewSet(viewsets.ModelViewSet):
    serializer_class = AlerteSerializer
    
    def get_queryset(self):
        return Alerte.objects.select_related(
            'dossier__patient', 'utilisateur'
        ).order_by('-dateAlerte', '-idAlerte')
'''
            
            # Sauvegarder le patch
            with open('optimisations_viewset.py', 'w', encoding='utf-8') as f:
                f.write(patch_content)
            
            self.log_implementation(
                "Optimisation ViewSets",
                "Patch d'optimisation cr√©√©: optimisations_viewset.py",
                "succes"
            )
            
        except Exception as e:
            self.log_implementation(
                "Optimisation ViewSets",
                f"Erreur lors de la cr√©ation du patch: {e}",
                "erreur"
            )
    
    def implementer_monitoring(self):
        """Impl√©menter le monitoring de base"""
        try:
            # Cr√©er un middleware de monitoring simple
            monitoring_content = '''
import time
import logging
from django.utils.deprecation import MiddlewareMixin

logger = logging.getLogger('performance')

class PerformanceMonitoringMiddleware(MiddlewareMixin):
    def process_request(self, request):
        request.start_time = time.time()
    
    def process_response(self, request, response):
        if hasattr(request, 'start_time'):
            duration = time.time() - request.start_time
            if duration > 1.0:  # Log les requ√™tes lentes (> 1s)
                logger.warning(
                    f'Requ√™te lente: {request.path} - {duration:.3f}s'
                )
        return response
'''
            
            # Sauvegarder le middleware
            with open('performance_middleware.py', 'w', encoding='utf-8') as f:
                f.write(monitoring_content)
            
            self.log_implementation(
                "Monitoring Performance",
                "Middleware de monitoring cr√©√©: performance_middleware.py",
                "succes"
            )
            
        except Exception as e:
            self.log_implementation(
                "Monitoring Performance",
                f"Erreur lors de la cr√©ation du middleware: {e}",
                "erreur"
            )
    
    def optimiser_base_donnees(self):
        """Optimiser la configuration de la base de donn√©es"""
        try:
            # V√©rifier la configuration actuelle
            db_config = settings.DATABASES['default']
            
            # Recommandations pour PostgreSQL
            recommendations = {
                'CONN_MAX_AGE': 600,  # 10 minutes
                'OPTIONS': {
                    'MAX_CONNS': 20,
                    'MIN_CONNS': 5,
                }
            }
            
            print("üìù Recommandations pour optimiser PostgreSQL:")
            print("Dans settings.py, ajoutez √† DATABASES['default']:")
            for key, value in recommendations.items():
                print(f"    '{key}': {value},")
            
            self.log_implementation(
                "Optimisation Base de Donn√©es",
                "Recommandations PostgreSQL fournies",
                "succes"
            )
            
        except Exception as e:
            self.log_implementation(
                "Optimisation Base de Donn√©es",
                f"Erreur lors de l'analyse: {e}",
                "erreur"
            )
    
    def creer_script_maintenance(self):
        """Cr√©er un script de maintenance automatique"""
        try:
            maintenance_script = '''#!/usr/bin/env python
"""
Script de maintenance automatique pour le syst√®me de conformit√© m√©dicale
√Ä ex√©cuter quotidiennement via cron
"""

import os
import sys
import django
from datetime import datetime, timedelta

# Configuration Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend_project.settings')
django.setup()

from django.core.cache import cache
from django.db import connection
from api.models import Alerte, Acces, DemandeExportation

def nettoyer_cache():
    """Nettoyer le cache expir√©"""
    print("üßπ Nettoyage du cache...")
    # Le cache Django se nettoie automatiquement
    
def nettoyer_logs_anciens():
    """Nettoyer les logs anciens"""
    print("üìã Nettoyage des logs anciens...")
    # Supprimer les alertes de plus de 1 an
    date_limite = datetime.now().date() - timedelta(days=365)
    alertes_supprimees = Alerte.objects.filter(dateAlerte__lt=date_limite).count()
    Alerte.objects.filter(dateAlerte__lt=date_limite).delete()
    print(f"   {alertes_supprimees} alertes anciennes supprim√©es")

def optimiser_base_donnees():
    """Optimiser la base de donn√©es"""
    print("üóÑÔ∏è Optimisation de la base de donn√©es...")
    with connection.cursor() as cursor:
        cursor.execute("VACUUM ANALYZE;")
    print("   VACUUM ANALYZE termin√©")

def verifier_integrite():
    """V√©rifier l'int√©grit√© des donn√©es"""
    print("üîç V√©rification de l'int√©grit√©...")
    
    # V√©rifier les dossiers orphelins
    dossiers_orphelins = DossierMedical.objects.filter(patient__isnull=True).count()
    if dossiers_orphelins > 0:
        print(f"   ‚ö†Ô∏è {dossiers_orphelins} dossiers orphelins d√©tect√©s")
    
    # V√©rifier les demandes d'exportation expir√©es
    demandes_expirees = DemandeExportation.objects.filter(
        statut='EN_ATTENTE',
        date_demande__lt=datetime.now() - timedelta(days=30)
    ).count()
    if demandes_expirees > 0:
        print(f"   ‚ö†Ô∏è {demandes_expirees} demandes d'exportation expir√©es")

def main():
    """Fonction principale"""
    print(f"üöÄ Maintenance automatique - {datetime.now()}")
    print("="*50)
    
    nettoyer_cache()
    nettoyer_logs_anciens()
    optimiser_base_donnees()
    verifier_integrite()
    
    print("‚úÖ Maintenance termin√©e avec succ√®s")

if __name__ == "__main__":
    main()
'''
            
            # Sauvegarder le script
            with open('maintenance_automatique.py', 'w', encoding='utf-8') as f:
                f.write(maintenance_script)
            
            self.log_implementation(
                "Script Maintenance",
                "Script de maintenance cr√©√©: maintenance_automatique.py",
                "succes"
            )
            
        except Exception as e:
            self.log_implementation(
                "Script Maintenance",
                f"Erreur lors de la cr√©ation du script: {e}",
                "erreur"
            )
    
    def generer_rapport(self):
        """G√©n√©rer un rapport d'impl√©mentation"""
        print("\n" + "="*60)
        print("üöÄ RAPPORT D'IMPL√âMENTATION DES OPTIMISATIONS")
        print("="*60)
        
        print(f"\nüìä R√âSULTATS:")
        print(f"   ‚úÖ Impl√©mentations r√©ussies: {len(self.results['succes'])}")
        print(f"   ‚ùå Erreurs: {len(self.results['erreurs'])}")
        print(f"   üìã Total: {len(self.results['implementations'])}")
        
        if self.results['succes']:
            print(f"\n‚úÖ IMPL√âMENTATIONS R√âUSSIES:")
            for succes in self.results['succes']:
                print(f"   ‚Ä¢ {succes}")
        
        if self.results['erreurs']:
            print(f"\n‚ùå ERREURS:")
            for erreur in self.results['erreurs']:
                print(f"   ‚Ä¢ {erreur}")
        
        print(f"\nüìÅ FICHIERS CR√â√âS:")
        fichiers = [
            'optimisations_viewset.py',
            'performance_middleware.py', 
            'maintenance_automatique.py'
        ]
        for fichier in fichiers:
            if os.path.exists(fichier):
                print(f"   ‚Ä¢ {fichier}")
        
        print(f"\nüìù PROCHAINES √âTAPES:")
        print("   1. Appliquer les optimisations ViewSets")
        print("   2. Configurer le middleware de performance")
        print("   3. Programmer la maintenance automatique")
        print("   4. Tester les performances")
        
        # Sauvegarder le rapport
        import json
        rapport_file = f"rapport_implementation_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(rapport_file, 'w', encoding='utf-8') as f:
            json.dump(self.results, f, indent=2, ensure_ascii=False, default=str)
        
        print(f"\nüìÑ Rapport sauvegard√©: {rapport_file}")
        print("="*60)
    
    def executer_implementations(self):
        """Ex√©cuter toutes les impl√©mentations"""
        print("üöÄ D√âMARRAGE DES IMPL√âMENTATIONS D'OPTIMISATION")
        print("="*60)
        
        implementations = [
            self.implementer_cache_redis,
            self.implementer_compression_gzip,
            self.optimiser_requetes_viewset,
            self.implementer_monitoring,
            self.optimiser_base_donnees,
            self.creer_script_maintenance,
        ]
        
        for implementation in implementations:
            try:
                implementation()
            except Exception as e:
                print(f"‚ùå Erreur lors de {implementation.__name__}: {e}")
        
        self.generer_rapport()

if __name__ == "__main__":
    implementateur = ImplementationOptimisations()
    implementateur.executer_implementations() 